# Structure of .ini configuration file

- name: (string) Name of the folder for the results file
- n_min: (int) Minimum value of n of the instances to be considered
- n_max: (int) Maximum value of n of the instances to be considered
- manifold: (bool) Activates UBT-manifold condition iff True
- time_limit: (float) Maximum time allowed for computation for each instance
- mipgap: (float) Maximum allowed optimality gap
- buneman_violation: (bool) Imposes violation of Buneman' strong four-point condition iff True
- buneman_disjunctive: (bool) Imposes Buneman' strong four-point condition iff True
- buneman_custom_constraints: (bool) Loads fixed values of the y binary variables in Formulation 1 iff True
- circular_orders_custom_constraints: (bool) Loads preset circular order facet-defining inequalities on n - 1 leaves iff True
- circular_orders_custom_filepath: (string) Path to preset circular order facet-defining inequalitie
- solver_mode: (categorical) SolverMode.Barebone (disable preprocessing and internal cuts) / SolverMode.Turbo (aggressive preprocessing, high heuristic frequency, high optimality gap) / SolverMode.Default (default options)
- instance_path: (string/categorical) Path to instances
- mode: (categorical)
- order_first_row: (bool) Imposes non-decreasing order on the first row of tau matrix iff True
- entries_equal_to_two: (bool) imposes the number of entries equal to 2 in upper triangular (or lower triangular) matrix
- fast_branching: (bool) Increases branching priority for lower values of tau, i.e., imposes a higher branching priority for x_{i, j}^l w.r.t. to each x_{i, j}^{l'} with l < l'
- start: (int) initial number for the matrices that violate Buneman conditions when execution mode is Buneman Violation
- repeat: (int) Number of times "main.py" iterates, for each fixed j = entries_equal_to_two, ..., 2, trying to obtain infeasibility when execution mode is Buneman Violation
